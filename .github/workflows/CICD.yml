name: CICD

on:
  push:
    branches: [ "main" ]

permissions:
  contents: read

concurrency:
  group: cicd-main
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: 'gradle'

      - name: application.yml 디렉토리 만들기
        run: mkdir -p ./src/main/resources/

      - name: application.yml 파일 만들기
        run: echo "${{ secrets.APPLICATION_PROPERTIES }}" > ./src/main/resources/application.yml

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build with Gradle
        run: ./gradlew clean build --no-daemon

      - name: Set up Docker QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Docker Build and Push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/on_server:latest

  deploy-server:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Decide target upstream/ports
        shell: bash
        run: |
          set -euo pipefail
          URL="https://${{ secrets.ON_SERVER_IP }}/env"
          STATUS="$(curl -s -o /dev/null -w "%{http_code}" "$URL" || true)"
          echo "Probe /env HTTPs status: ${STATUS:-<empty>}"

          if [ "${STATUS:-000}" -eq 200 ]; then
            CURRENT_UPSTREAM="$(curl -s "$URL" | tr -d '\"[:space:]')"
            echo "CURRENT_UPSTREAM(raw)=$CURRENT_UPSTREAM"
          else
            echo "Server not responding, defaulting CURRENT_UPSTREAM=green"
            CURRENT_UPSTREAM="green"
          fi

          # normalize
          if [ "$CURRENT_UPSTREAM" = "blue" ]; then
            echo "CURRENT_PORT=8080" >> "$GITHUB_ENV"
            echo "NEW_PORT=8081"     >> "$GITHUB_ENV"   # previously stopped, now target port
            echo "TARGET_UPSTREAM=green" >> "$GITHUB_ENV"
          else
            echo "CURRENT_PORT=8081" >> "$GITHUB_ENV"
            echo "NEW_PORT=8080"     >> "$GITHUB_ENV"
            echo "TARGET_UPSTREAM=blue" >> "$GITHUB_ENV"
          fi
          echo "CURRENT_UPSTREAM=$CURRENT_UPSTREAM" >> "$GITHUB_ENV"

      - name: Prepare .env on EC2
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.ON_SERVER_IP }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_KEY }}
          script_stop: true
          script: |
            set -euo pipefail
            ENV_PATH="/home/ubuntu/filmfly.env"
            # :> "$ENV_PATH" # 필요 시 기존 비우기
            grep -q '^ON_SERVER_IP=' "$ENV_PATH" 2>/dev/null || true
            sed -i '/^ON_SERVER_IP=/d' "$ENV_PATH" 2>/dev/null || true
            echo "ON_SERVER_IP=${{ secrets.ON_SERVER_IP }}" >> "$ENV_PATH"
            echo "Updated $ENV_PATH"
            ls -l "$ENV_PATH" && tail -n +1 "$ENV_PATH"

      - name: Docker compose up new upstream
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.ON_SERVER_IP }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_KEY }}
          script_stop: true
          script: |
            set -euo pipefail
            # ⚠️ compose 파일이 있는 디렉터리로 이동 (필수)
            cd /home/ubuntu
            # Compose v1/v2 환경에 맞게 하나만 사용
            DOCKER_COMPOSE="docker compose"
            if ! docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE="docker-compose"
            fi

            sudo docker pull ${{ secrets.DOCKERHUB_USERNAME }}/on_server:latest
            # Redis 등 공통 서비스
            sudo $DOCKER_COMPOSE -f docker-compose-redis.yml up -d
            # 새 업스트림(NEW_PORT에 매핑) 기동
            sudo $DOCKER_COMPOSE --env-file /home/ubuntu/filmfly.env -f docker-compose-${{ env.TARGET_UPSTREAM }}.yml up -d

      - name: Health Check on NEW_PORT
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.ON_SERVER_IP }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_KEY }}
          script_stop: true
          script: |
            set +e
            # NGINX를 거치지 않고, 새로 띄운 Docker 컨테이너의 포트로 직접 헬스체크
            # EC2 인스턴스 내부에서 localhost를 사용하여 NEW_PORT로 접근합니다.
            URL="http://localhost:${{ env.NEW_PORT }}/env" # HTTP 사용
            echo "Health checking new upstream at $URL"
            for i in {1..12}; do # 헬스체크 시도 횟수 및 대기 시간을 늘림 (12 * 5초 = 60초)
              sleep 5 # 5초 대기
              STATUS="$(curl -s -o /dev/null -w "%{http_code}" "$URL" || true)"
              echo "Attempt $i -> $STATUS"
              if [ "$STATUS" = "200" ]; then
                echo "Health check passed for NEW_PORT"
                exit 0
              fi
            done
            echo "Health check failed for NEW_PORT after multiple attempts"
            exit 1

      - name: Switch nginx upstream
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.ON_SERVER_IP }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_KEY }}
          script_stop: true
          script: |
            set -euo pipefail
            # nginx 컨테이너 이름 확인 필요: nginxserver
            sudo docker exec -i nginxserver bash -c 'echo "set \$service_url ${{ env.TARGET_UPSTREAM }};" > /etc/nginx/conf.d/service-env.inc && nginx -s reload'
            echo "Nginx switched to ${{ env.TARGET_UPSTREAM }}"

      - name: Stop previous upstream
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.ON_SERVER_IP }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_KEY }}
          script_stop: true
          script: |
            set -euo pipefail
            # 컨테이너 이름이 blue/green과 1:1이면 OK
            sudo docker stop ${{ env.CURRENT_UPSTREAM }} || true
            sudo docker rm   ${{ env.CURRENT_UPSTREAM }} || true
            echo "Stopped & removed ${{ env.CURRENT_UPSTREAM }}"
